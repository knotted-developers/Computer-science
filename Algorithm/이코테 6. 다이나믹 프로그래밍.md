`양미화`

<h1> 다이나믹 프로그래밍 </h1>

> <a href="https://www.youtube.com/watch?v=5Lu34WIx2Us&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC&index=6" target="_blacnk"> [2021 이코테] **6. 다이나믹 프로그래밍**  </a> 

<h2> 다이나믹 프로그래밍 </h2>

- 다이나믹 프로그래밍은 **메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법**
- **이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장**하여 다시 계산하지 않도록 함
- 다이나믹 프로그래밍의 구현은 일반적으로 **두 가지 방식(탑다운과 보텀업)**으로 구성


- 다이나믹 프로그래밍은 **동적 계획법**이라고도 부름
- 일반적인 프로그래밍 분야에서의 동적(Dynamic)이란 어떤 의미를 가질까?
  - 자료구조에서 **동적 할당(Dynamic Allocation)**은 **'프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법'**을 의미
  - 반면에 다이나믹 프로그래밍에서 '다이나믹'은 별다른 의미 없이 사용된 단어


- 다이나믹 프로그래밍은 문제가 다음의 조건을 만족할 떄 사용 가능
  - 1. **최적 부분 구조 (Optimal Substructure)**
    - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있음
  - 2. **중복되는 부분 문제 (Overlapping Subproblem)**
    - 동일한 작은 문제를 반복적으로 해결해야 함

<h3> 피보나치 수열 </h3>

- **피보나치 수열**은 다음과 같은 형태의 수열이며, 다이나믹 프로그래밍으로 효과적으로 계산 가능
  - 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
- **점화식**이란 **인접한 항들 사이의 관계식**을 의미
- 피보나치 수열을 점화식으로 표현하면 다음과 같음
  - `a(n) = a(n-1) + a(n-2)`
  - `a(1) = 1, a(2) = 1`
- 피보나치 수열이 계산되는 과정은 다음과 같이 표현할 수 있음
  - 프로그래밍에서는 이러한 수열을 **배열이나 리스트를 이용**해 표현

![](https://images.velog.io/images/hwaya2828/post/b2edc90b-efd1-4618-80bd-e1ae5fce817c/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-12%20%EC%98%A4%ED%9B%84%202.50.21.png)

- 피보나치 수열이 계산되는 과정은 다음과 같이 표현할 수 있음
  - n번째 피보나치 수를 f(n)라고 할 때 4번째 피보나치 수 f(4)를 구하는 과정은 다음과 같음

![](https://images.velog.io/images/hwaya2828/post/0e38a37a-f241-456a-8dab-27b390378ae9/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-12%20%EC%98%A4%ED%9B%84%202.54.47.png)

```python
# 피보나치 함수(Fibonacci Function)을 재귀함수로 구현
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)

print(fibo(4))

>>> 3
```

<h4> 피보나치 수열의 시간 복잡도 분석 </h4>

- 단순 재귀 함수로 피보나치 수열을 해결하면 지수 시간 복잡도를 가지게 됨
- 다음과 같이 f(2)가 여러번 호출되는 것을 확인할 수 있음 (중복되는 부분 문제)

![](https://images.velog.io/images/hwaya2828/post/9bf66e76-1841-4b9e-a493-f512c41767ff/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-12%20%EC%98%A4%ED%9B%84%203.08.11.png)

- 피보나치 수열의 시간 복잡도는 다음과 같음
  - 세타 표기법: 𝜃(1.618⋯ᴺ)
  - 빅오 표기법: O(2ᴺ)
- 빅오 표기법을 기준으로 f(30)을 계산하기 위해 약 10억가량의 연산을 수행해야 함

<h3> 피보나치 수열의 효율적인 해법: 다이나믹 프로그래밍 </h3>

- **다이나믹 프로그래밍의 사용 조건**을 만족하는지 확인
  - 1. **최적 부분 구조**: 큰 문제를 작은 문제로 나눌 수 있음
  - 2. **중복되는 부분 문제**: 동일한 작은 문제를 반복적으로 해결
- 피보나치 수열은 다이나믹 프로그래밍의 사용 조건을 만족

<h3> 메모이제이션 (Memoization) </h3>

- **메모이제이션**은 다이나믹 프로그래밍을 구현하는 방법 중 하나 (**탑다운 방식=하향식**)
- **한 번 계산한 결과를 메모리 공간에 메모하는 기법**
  - 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옴
  - 값을 기록해 놓는다는 점에서 **캐싱(Caching)**이라고도 함

<h3> 탑다운 vs 보텀업 </h3>

- **탑다운(메모이제이션) 방식**은 **하향식**이라고도 하며 **보텀업 방식**은 **상향식**이라고도 함
- **다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식**
  - **결과 저장용 리스트는 DP 테이블**이라고 부름
- 엄밀히 말하면 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미
  - 따라서 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아님
  - 한 번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있음

```python
# 피보나치 수열: 탑다운 다이나믹 프로그래밍 소스코드

# 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수(Fibonacci Function)를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
def fibo(x):
    # 종료 조건(1 혹은 2일 때 1을 반환)
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]
    # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]

print(fibo(99))

>>> 218922995834555169026
```

```python
# 피보나치 수열: 보텀업 다이나믹 프로그래밍 소스코드

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

# 첫번째 피보나치 수와 두번째 피보나치 수는 1
d[1] = 1
d[2] = 2
n = 99

# 피보나치 함수(Fibonacci Function) 반복문으로 구현(보텀업 다이나믹 프로그래밍)
for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]

print(d[n])

>>> 218922995834555169026
```

<h4> 피보나치 수열: 메모이제이션 동작 분석 </h4>

- 이미 계산된 결과를 메모리에 저장하면 다음과 같이 색칠된 노드만 처리할 것을 기대할 수 있음

![](https://images.velog.io/images/hwaya2828/post/2ddd0405-d078-4d41-b2a0-10d4b2f7ab9a/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-13%20%EC%98%A4%ED%9B%84%2012.02.05.png)

- 실제로 호출되는 함수에 대해서만 확인해보면 다음과 같이 방문

![](https://images.velog.io/images/hwaya2828/post/f5ae0dab-2959-490a-8236-0919140da4f3/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-12%20%EC%98%A4%ED%9B%84%208.16.01.png)

- 메모이제이션을 이용하는 경우 피보나치 수열 함수의 시간 복잡도는 O(N)

```python
d = [0] * 100

def fibo(x):
    print('f(' + str(x) + ')', end=' ')
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]

fibo(6)

>>>> f(6) f(5) f(4) f(3) f(2) f(1) f(2) f(3) f(4)
```

<h3> 다이나믹 프로그래밍 vs 분할 정복 </h3>

- **다이나믹 프로그래밍**과 **분할 정복**은 **모두 최적 부분 구조를 가질 때 사용 가능**
  - **큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황**
- 다이나믹 프로그래밍과 분할 정복의 **차이점**은 **부분 문제의 중복**
  - 다이나믹 프로그래밍 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복
  - 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않음


- **분할 정복**의 대표적인 예시로 **퀵 정렬**이 있음
  - 한 번 기준 원소(Pivot)가 자리를 변경해서 자리를 잡으면 그 기준 원소의 위치는 바뀌지 않음
  - 분할 이후에 해당 피벗을 다시 처리하는 부분 문제는 호출하지 않음

![](https://images.velog.io/images/hwaya2828/post/396936b6-56f3-4c99-b199-1635c1fc411e/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-12%20%EC%98%A4%ED%9B%84%208.23.11.png)

<h4> 다이나믹 프로그래밍 문제에 접근하는 방법 </h4>

- 주어진 문제가 **다이나믹 프로그래밍 유형임을 파악**하는 것이 중요
- 가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는지 검토할 수 있음
  - 다른 알고리즘으로 풀이 방법이 떠오르지 않는다면 다이나믹 프로그래밍을 고려
- 일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에 (탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 코드를 개선하는 방법을 사용할 수 있음
- 일반적인 코딩 테스트 수준에서는 기본 유형의 다이나믹 프로그래밍 문제가 출제되는 경우가 많음

<h3> 문제: 개미 전사 </h3>

![](https://images.velog.io/images/hwaya2828/post/3bff23c7-16eb-4c5b-8344-dae0d7db0443/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-12%20%EC%98%A4%ED%9B%84%208.27.38.png)

<h4> 문제 해결 아이디어 </h4>

- 예시를 확인해 보면 N = 4일 때, 다음과 같은 경우들이 존재할 수 있음
  - 식량을 선택할 수 있는 경우의 수는 다음과 같이 8가지
  - 7번쨰 경우에서 8만큼의 식량을 얻을 수 있으므로 최적의 해는 8


- a(i) = i번째 식량 창고까지의 최적의 해 (얻을 수 있는 식량의 최댓값)
  - 이렇게 정의한다면 다이나믹 프로그래밍을 적용할 수 있음

![](https://images.velog.io/images/hwaya2828/post/6515d39c-ebb2-42cc-bc22-cdf2dcf612b8/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-12%20%EC%98%A4%ED%9B%84%208.30.49.png)

- 왼쪽부터 차례대로 식량 창고를 턴다고 했을 때, 특정한 i번째 식량 창고에 대해서 털지 안 털지의 여부를 결정하면, 아래 2가지 경우 중에서 더 많은 식량을 털 수 있는 경우를 선택하면 됨

![](https://images.velog.io/images/hwaya2828/post/ee62f37e-8fbb-40fa-8984-327a0b822076/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-12%20%EC%98%A4%ED%9B%84%208.32.32.png)

- a(i) = i번째 식량 창고까지의 최적의 해 (얻을 수 있는 식량의 최댓값)
- k(i) = i번째 식량 창고에 있는 식량의 양
- 점화식은 다음과 같음
  - `a(i) = max(a(i-1), a(i-2) + k(i))`
- 한 칸 이상 떨어진 식량 창고는 항상 털 수 있으므로 (i-3)번째 이하는 고려할 필요가 없음

```python
# 정수 N을 입력 받기
n = int(input())
# 모든 식량 정보 입력 받기
array = list(map(int, input().split())

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

# 다이나믹 프로그래밍(Dynamic Programming) 진행 (보텀업)
d[0] = array[0]
d[1] = max(array[0], array[1])
for i in range(2, n):
    d[i] = max(d[i - 1], d[i - 2] + array[i])

# 계산된 결과 출력
print(d[n - 1])
```

<h3> 문제: 1로 만들기 </h3>

![](https://images.velog.io/images/hwaya2828/post/34f6cdb7-698a-4d78-ac50-13989a2327b5/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-12%20%EC%98%A4%ED%9B%84%208.48.13.png)

<h4> 문제 해결 아이디어 </h4>

- 피보나치 수열 문제를 도식화 한 것처럼 함수가 호출되는 과정을 그림으로 그려보면 다음과 같음
  - 최적 부분 구조와 중복되는 부분 문제를 만족

![](https://images.velog.io/images/hwaya2828/post/9e771970-a529-4b0d-b93c-dc78e2b3c3b6/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-12%20%EC%98%A4%ED%9B%84%208.50.56.png)

- a(i) = i를 1로 만들기 위한 최소 연산 횟수
- 점화식은 다음과 같음
  - `a(i) = min(a(i-1), a(i/2), a(i/3), a(i/5)) + 1`
- 단, 1을 빼는 연산을 제외하고는 해당 수로 나누어떨어질 때에 한해 점화식을 적용할 수 있음

```python
# 정수 X를 입력 받기
x = int(input())

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 30001

# 다이나믹 프로그래밍(Dynamic Programming) 진행 (보텀업)
for i in range(2, x + 1):
    # 현재의 수에서 1을 빼는 경우
    d[i] = d[i - 1] + 1
    # 현재의 수가 2로 나누어 떨어지는 경우
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)
    # 현재의 수가 3으로 나누어 떨어지는 경우
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
    # 현재의 수가 5로 나누어 떨어지는 경우
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)

print(d[x])
```

<h3> 문제: 효율적인 화폐 구성 </h3>

![](https://images.velog.io/images/hwaya2828/post/b2024887-3fe5-4e3d-b815-66c12d052c6d/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-12%20%EC%98%A4%ED%9B%84%209.00.34.png)

<h4> 문제 해결 아이디어 </h4>

- a(i) = 금액 i를 만들 수 있는 최소한의 화폐 개수
- k = 각 화폐의 단위
- 점화식: 각 화폐 단위인 k를 하나씩 확인하며
  - a(i-k)를 만드는 방법이 존재하는 경우, `a(i) = min(a(i), a(i-k) + 1)`
  - a(i-k)를 만드는 방법이 존재하지 않는 경우, `a(i) = INF`


- N = 3, M = 7이고, 각 화폐의 단위가 2, 3, 5인 경우 확인
![](https://images.velog.io/images/hwaya2828/post/05cb0c5f-0d7b-4c0e-b776-408b50788750/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-12%20%EC%98%A4%ED%9B%84%209.04.37.png)
![](https://images.velog.io/images/hwaya2828/post/393ba5b1-4c6d-410d-acfd-05c6a066fb8a/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-12%20%EC%98%A4%ED%9B%84%209.05.26.png)
![](https://images.velog.io/images/hwaya2828/post/9236e2d6-94eb-4955-b920-01afacf3f2e0/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-12%20%EC%98%A4%ED%9B%84%209.06.24.png)
![](https://images.velog.io/images/hwaya2828/post/92bfa7f5-3df7-461d-b012-e9418f0f8437/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-12%20%EC%98%A4%ED%9B%84%209.06.52.png)

```python
# 정수 N, M을 입력 받기
n, m = map(int, input().split())
# N개의 화폐 단위 정보를 입력받기
array = []
for i in range(n):
    array.append(int(input()))

# 한번 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [10001] * (m + 1)

# 다이나믹 프로그래밍(Dynamic Programming) 진행(보텀업)
d[0] = 0
for i in range(n):
    for j in range(array[i], m + 1):
        if d[j - array[i]] != 10001: # (i-k)원을 만드는 방법이 존재하는 경우
            d[j] = min(d[j], d[j - array[i]] + 1)

# 계산된 결과 출력
if d[m] == 10001: # 최종적으로 M원을 만드는 방법이 없는 경우
    print(-1)
else:
    print(d[m])
```

<h3> 문제: 금광 </h3>

![](https://images.velog.io/images/hwaya2828/post/cf66376d-5994-4fe0-96ad-7ac58af7358c/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-12%20%EC%98%A4%ED%9B%84%209.32.24.png)

<h4> 문제 해결 아이디어 </h4>

- 금광의 모든 위치에 대하여 다음의 세 가지만 고려하면 됨
  - 1. 왼쪽 위에서 오는 경우
  - 2. 왼쪽 아래에서 오는 경우
  - 3. 왼쪽에서 오는 경우
- 세 가지 경우 중에서 가장 많은 금을 가지고 있는 경우를 테이블에 갱신해주어 문제를 해결


- array[i][j] = i행 j열에 존재하는 금의 양
- dp[i][j] = i행 j열까지의 최적의 해 (얻을 수 있는 금의 최댓값)
- 점화식은 다음과 같음
  - `dp[i][j] = array[i][j] + max(dp[i - 1][j - 1], dp[i][j - 1], dp[i + 1][j - 1])`
- 이때 테이블에 접근할 때마다 리스트의 범위를 벗어나지 않는지 체크해야 함
- 편의상 초기 데이터를 담는 변수 array를 사용하지 않아도 됨
  - 바로 DP 테이블에 초기 데이터를 담아서 다이나믹 프로그래밍을 적용할 수 있음

![](https://images.velog.io/images/hwaya2828/post/a054e9a2-abb4-4f9b-9a9b-31e78890832b/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-12%20%EC%98%A4%ED%9B%84%209.44.40.png)

```python
# 테스트 케이스(Test Case) 입력
for tc in range(int(input())):
    # 금광 정보 입력
    n, m = map(int, input().split())
    array = list(map(int, input().split())
    # 다이나믹 프로그래밍을 위한 2차원 DP 테이블 초기화
    dp = []
    index = 0
    for i in range(n):
        dp.append(array[index:index + m])
        index += m
    # 다이나믹 프로그래밍 전형
    for j in range(1, m):
        for i in range(n):
            # 왼쪽 위에서 오는 경우
            if i == 0: left_up = 0
            else: left_up = dp[i - 1][j - 1]
            # 왼쪽 아래에서 오는 경우
            if i == n - 1: left_down = 0
            else: left_down = dp[i + 1][j - 1]
            # 왼쪽에서 오는 경우
            left = dp[i][j - 1]
            dp[i][j] = dp[i][j] + max(left_up, left_down, left)
    result = 0
    for i in range(n):
        result = max(result, dp[i][m - 1])
    print(result)
```

<h3> 문제: 병사 배치하기 </h3>

![](https://images.velog.io/images/hwaya2828/post/a9edbd44-380e-4942-bec7-6658aef34dfc/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-12%20%EC%98%A4%ED%9B%84%209.54.32.png)

<h4> 문제 해결 아이디어 </h4>

- 이 문제의 기본 아이디어는 **가징 긴 증가하는 부분 수열(Longest Increasing Subsequence, LIS)**로 알려진 전형적인 다이나믹 프로그래밍 문제의 아이디어와 같음
- 예를 들어 하나의 수열 array = [4, 2, 5, 8, 4, 11, 15]이 있을 때
  - 이 수열의 가장 긴 증가하는 부분 수열은 [4, 5, 8, 11, 15]
- 본 문제는 가장 긴 감소하는 부분 수열을 찾는 문제로 치환할 수 있으므로, LIS 알고리즘을 조금 수정하여 적용함으로써 정답 도출 가능


- **가장 긴 증가하는 부분 수열(LIS) 알고리즘**
- D[i] = array[i]를 마지막 원소로 가지는 부분 수열의 최대 길이
- 점화식은 다음과 같음
  - 모든 0 ≤ j < i 에 대하여, `D[i] = max(D[i], D[j] + 1) if array[j] < array[i]`

![](https://images.velog.io/images/hwaya2828/post/47e5c88f-80a5-443c-9c8c-92ce5bbe05f5/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-08-12%20%EC%98%A4%ED%9B%84%2010.01.15.png)

- 가장 먼저 입력 받은 병사 정보의 순서를 뒤집음
- 가장 긴 증가하는 부분 수열(LIS) 알고리즘을 수행하여 정답을 도출

```python
n = int(input())
array = list(map(int, input().split()))
# 순서를 뒤집어 '최장 증가 부분 수열' 문제로 변환
array.reverse()

# 다이나믹 프로그래밍을 위한 1차원 DP 테이블 초기화
dp = [1] * n

# 가장 긴 증가하는 부분 수열(LIS) 알고리즘 수행
for i in range(1, n):
    for j in range(0, i):
        if array[j] < array[i]:
            dp[i] = max(dp[i], dp[j] + 1)

# 열외해야 하는 병사의 최소 수를 출력
print(n - max(dp))
```



