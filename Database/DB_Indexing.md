> ## 💌 DB Indexing이란?
RDBMS에서 검색속도를 높이기 사용하는 하나의 기술.
INDEX는 색인이라고 생각하면 편함. 해당 TABLE의 컬럼을 색인화(따로 파일로 저장)하여 검색시 해당 TABLE의 레코드를 full scan 하는게 아니라 **색인화 되어있는 INDEX 파일을 검색하여 검색속도를 빠르게!**

> ## 💌  Index의 종류?
1. B(Balanced)+tree Index
2. Bitmap Index
3. IOT Index
4. Clustered Index
* 주로 B+tree 구조로 사용됨!

> ## 💌 B+tree 구조가 뭘까.......?^^
![](https://images.velog.io/images/majaeh43/post/b9366828-4167-4712-84ce-ab54043afbfb/image.png)
> 📩  B+Tree구성
* 루트노드: 경로의 출발점 노드
* 논리노드: 리프 노드까지의 경로 역할을 하는 노드
> * 리프노드: 실제 데이터가 저장되는 노드
> * B+Tree는 리프 노드에 이르기까지 자식 노드에 대한 포인터가 저장되어 있어 탐색에 있어 루트 노드에서 어떤 리프노드에 이르는 한 개의 경로만 검색하면 되기 때문에 검색에 있어 매우 효율적인 알고리즘이다.

> ## 💌  왜 사용해야하지?
-> 검색 속도를 높여주니까! 우리가 책에서 원하는 페이지를 찾을 때에도 색인 목록을 확인하는 이유랑 같다고 보면 됨. 검색속도를 높여주어 데이터를 빠르게 관리, 검색 할 수 있게 도와쥼! 넘좋지...🎀
> 
![](https://images.velog.io/images/majaeh43/post/cd8a844b-9d8a-4840-9984-b6f81c7c9e95/image.png)
> 
* 예를 들어, 위 테이블의 Physics값을 조회한다고 해보장!
* select 절을 활용해서 조회하거나 or 어느 위치에 데이터가 존재하는지 모르기 때문에 Table Full scan을 진행할 것임.
> * 근데 만약에 수십만개 데이터가 들어있는 테이블의 데이터를 조회하는데, 검색을 자주 해야하는 상황이 계속 발생한다면 진짜 짜증나게찌....
> * 그니까 위와 같이 인덱스를 따로 생성해서 해당 데이터만 빠르게 찾을 수 있게 됨으로써 성능향상을 기대하는 것이야...🎈

> ## 💌 어떻게 동작하는데?
1. 해당 테이블을 생성시 생성하고 싶은 인덱스 컬럼을 지정
2. 생성 후 인덱스 조회 시, WHERE 절이 포함된 쿼리로 조회
3. 인덱스로 저장된 Key-Value값을 참조해서 결과 출력

> ## 💌 예를 들어볼게!
예시) 
* 사원 테이블에 총 50명이 있고, 남자 25명, 여자 25명
여자 중 이름이 '유관순'인 사람이 2명
사원 테이블에서 성별이 '여자' 이고 이름이 '유관순'인 사람을 찾을 때 :
SQL > SELECT 이름, 성별 FROM 사원 WHERE 성별 = '여자' AND 이름 = '유관순';
* 결합 인덱스 생성 구문 예 (중복을 허용하지 않는 예시) :
```
CREATE UNIQUE INDEX [인덱스명]
ON [테이블명]([컬럼명1][정렬기준], [컬럼명2][정렬기준], ...)
SQL > **CREATE UNIQUE INDEX** idx_사원_성별_이름 2 **ON** 사원(성별,이름);
```
* 결합 인덱스 생성시 컬럼의 배치 순서 
case 1 : ON 사원(성별, 이름) 
50 명 -> 여자 -> 25명 -> 유관순 -> 2명
        50                      => 25회 검사
case 2 : ON 사원(이름, 성별)
50명 -> 유관순 -> 2명 -> 여자 -> 2명
        50                      => 2회 검사
=> 같은 테이블에 같은 SQL이지만 결합 인덱스를 어떻게 생성하는가에 따라 속도나 검사 횟수가 완전히 달라지게 된다. (신중히 생성...)

> ## 💌 그럼 언제 사용하는데?
1. 데이터의 양이 많고 검색이 변경보다 잦은 경우(검색>>>>>변경)
기본적으로 이진 트리를 사용하기 때문에 이미 정렬이 되어있는 상태에서 추가, 수정, 삭제가 자주 일어나게 되면 인덱스에서도 마찬가지로 해당 동작들이 수행되기 때문에 성능 저하를 초래할 수 있음.
예를 들어, 한 쇼핑몰에 여러가지 카테고리가 존재할때 해당 카테고리의 상품들을 조회할때 이러한 인덱스 기능을 잘 사용하게 된다면 큰 효율을 발휘하게 되지만, 인스타그램같은 소셜 서비스들은 끊임없이 게시글이 작성되고 수정, 삭제되기 때문에 오히려 인덱싱을 하게되면 엄청난 성능 저하가 되기 때문에~~~~
2. 인덱스를 사용하고자 하는 컬럼의 값이 다양한 경우.
3. 주로 검색 및 조회를 할 때.


> ## 💌 Indexing의 장점
1. 데이터를 가져오기 위한 Input, output 작업이 많이 줄어들기 때문에 인덱스 구조에서 데이터베이스의 행을 이전만큼 접근할 필요가 없음.
2. 유저에게 필요한 데이터를 빠르게 탐색해 더 빠르게 제공.
3. 테이블 행에 연결을 할 필요가 없어 행 ID를 인덱스에 저장할 필요가 없기 때문에 데이블 공간이 줄어듦.
4. 기본 키의 값으로 데이터를 분류할 수 있음.

> ## 💌 Indexing의 단점
1. 인덱싱 데이터베이스 관리 시스템을 사용하기 위해선 유니크한 값을 지닌 테이블의 기본 키가 필요함.
2. 인덱스 된 데이터에서 다른 인덱스를 사용할 수 없음.
3. 인덱스로 정리된 테이블을 분할 할 수 없음.
4. SQL 인덱싱은 CRUD 쿼리의 성능을 감소시킴.


💌 출처1: https://velog.io/@bsjp400/Database-DB-%EC%9D%B8%EB%8D%B1%EC%8B%B1Indexing%EC%9D%B4%EB%9E%80

💌 출처2: https://lalwr.blogspot.com/2016/02/db-index.html
