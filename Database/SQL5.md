## <SQL 레벨업>
### 💛 1장 DBMS 아키텍처
#### 💛 1강 DBMS 아키텍처 개요
* 현재 사용되는 RDB(Relational Database) 제품은 많은데 모두 내부 아키텍처들이 조금씩 다름 but 모두 관계 모델이라는 수학적 이론을 바탕으로 함. 결국, 기본적인 구조 자체는 모두 같음.

* DBMS 내부에 어떠한 기능이 있는지 알아보장!! 👊 먼저, 용어정리!
1. 쿼리 평가 엔진
* 쿼리 평가 엔진은 사용자로부터 입력받은 SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지를 결정함. ✍️ **이 때 결정되는 계획을 '실행계획(or '실행플랜')이라고 부름.** -> 이렇게 실행계획에 기반을 두고 데이터에 접근하는 방법을 '접근 메서드'라고 부름! 

* 쿼리 평가 엔진은 계획을 세우고 실행하는 DBMS의 핵심 기능을 담당하는 모듈.
* 쿼리(query)는 '질의'를 나타내고 간단하게는 select 구문 생각하면되고, 넓게는 SQL 구문 전체라고 생각하면 됨!

2. 버퍼 매니저
* DBMS는 버퍼라는 특별한 용도로 사용하는 메모리 영역을 확보해 둠. 이 메모리 영역을 관리하는 것이 바로 버퍼 매니저.

3. 디스크 용량 매니저
* 데이터베이스는 프로그램 중에서도 가장 많은 데이터를 다루는 솝트웨어! 그렇기때문에 디스크 용량 매니저는 어디에 어떻게 데이터를 저장할지 관리하고 읽고 쓰기를 제어함 !

4. 트랜잭션 매니저와 락 매니저
* 상용 시스템에서 데이터베이스를 사용하는 사람이 엄청 많을거니까! 이때 각각의 처리는 DBMS 내부에 트랜잭션이라는 단위로 관리. 트랜잭션의 정합성을 유지하면서 실행 + 필요하면 데이터에 락을 걸어 다른 사람의 요청을 대기시키는 것이 둘의 역할.

5. 리커버리 매니저
* DBMS가 저장하는 데이터 중 절대 잃어버리면 안되는 데이터가 있는데 그걸 정기적으로 백업하고 복구해주는 일을 수행해주는 매니저!

#### 💛 2강 DBMS와 버퍼
* DBMS의 버퍼 매니저는 어떤 기능을 수행할까? 
* 버퍼는 성능에 굉장히 중요한 영향을 미침. 메모리는 한정적인데, 데이터베이스가 메모리에 저장하고자 하는 데이터는 엄청 많아. 그럼 여기서 어떻게 이걸 효율적으로 확보할 것인가- 하는 문제는 넘 중요하겠지1!

1. 공짜 밥은 존재할까?
* 기억비용이란? 데이터를 저장하는 데 소모되는 비용.
-> 많은 데이터를 오래 저장하려 하면 속도를 잃고, 속도를 얻고자 하면 많은 데이터를 오래 저장하기 힘들다는 트레이드오프가 발생 !

2. DBMS와 기억장치의 관계
* DBMS는 데이터 저장을 목적으로 하는 미들웨어. 그래서 기억장치와의 관계가 중요.

![](https://images.velog.io/images/majaeh43/post/3c1fda1c-458f-43d4-80aa-0a6b0ba01c95/image.png)

- 하드디스크(HDD): DBMS가 데이터를 저장하는 매체는 대부분 HDD. 하드디스크는 기억장치 계층에서 2차 기억장치로 분류. (1차는 메모리)

- 메모리: 메모리는 디스크에 비해 기억 비용이 굉장히 비쌈. 그래서 하드웨어 1대에 탑재할 수 있는 양이 크지 않음.

- 버퍼를 활용한 속도 향상: 그럼에도 **DBMS가 일부라도 데이터를 메모리에 올리려는 이유는 '성능 향상' 때문!** -> SQL 구문 실행 속도를 빠르게 만들기 위함. 그래서 자주 접근하는 데이터를 메무리 위에 올려두면, 디스크에서 데이터를 가져올 필요 없이 곧바로 메모리에서 읽어 빠르게 데이터 검색 가능!
* 그니까 디스크 접근을 줄일 수 있으면 큰 폭의 성능 향상이 가능하겠지! 이렇게 성능 향상을 목적으로 데이터를 저장하는 메모리를 버퍼라고 함!(사용자와 저장소 사이에서 SQL 구문의 디스크 접근을 줄여주는 역할) 대부분 메모리가 사용되는 경우가 많음!
* 버퍼 = 캐시 (같은용어로 사용)

* 이러한 고속 접근이 가능한 버퍼에 '데이터를 어떻게, 어느 정도의 기간 동안 올릴지'를 관리하는 것이 DBMS의 버퍼 매니저! 🌱

3. 메모리 위에 있는 두 개의 버퍼
1) 데이터 캐시
2) 로그 버퍼

* DBMS는 이러한 구 개의 역할을 하는 메모리 영역을 갖고 있고, 이는 사용자가 용도에 따라 크기를 변경하는 것이 가능!
* 데이터 캐시: 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역 (엄청 빠르겠찌~~~)

* 로그버퍼: 갱신처리(insert, delete, update, merge)와 관련이 있음! DBMS는 갱신과 관련된 SQL 구문을 사용자로부터 받으면 일단 로그 버퍼 위에 변경 정보를 보내고 그 이후에 디스크에 변경을 수행함 !

-> 데이터베이스의 갱신처리는 **SQL 구문의 실행시점과 저장소에 갱신하는 시점에 차이가 있는 비동기 처리**.

* 중요한건 DBMS는 '**저장소의 느림을 어떻게 보완할 것인가**'를 계속 고민해야해...📌 -> 이것에 대한 답으로 버퍼 메커니즘을 탑재하게 됨.

4. 메모리의 성질이 초래하는 트레이드 오프
* 위에서 '메모리가 가진 단점은 가격이 비싸서 보유할 수 있는 데이터 양이 적다!'라고 함. 근데 이거말고 단점이 또 있음 ^^

1) 휘발성: 메모리에는 데이터의 영속성이 없음. DBMS를 껐다 켜면 버퍼 위의 모든 데이터가 사라짐. 
2) 휘발성의 문제점: 장애가 발생했을 때 메모리에 있던 데이터가 모두 사라져버려 데이터 부정합을 발생시킴. 캐시의 경우에는 메모리 위의 데이터가 다 사라져도 원본 데이터는 디스크 위에 남아 있으니까 NO 상관. 그치만 로그 버퍼 위에 존재하는 데이터가 디스크 위 로그 파일에 반영되기 전에 장애가 발생해서 사라져버리면? 복구 불가...!

-> 로그 파일에 전달된 갱신 정보가 DBMS가 다운될 때 사라지는 현상은 DBMS가 갱신을 비동기로 하는 이상, 언제든 발생할 수 있는 문제.

-> 이를 피하고자 DBMS는 커밋 시점에 반드시 갱신 정보를 로그 파일에 씀으로써 장애가 발생해도 정합성을 유지할 수 있게 함. 커밋(COMMIT)이란 갱신 처리를 '확정'하는 것인데, DBMS는 커밋된 데이터를 영속화함.

-> 다시 말하면, 커밋 때는 반드시 디스크에 동기 접근이 일어남. 결국 여기서 지연이 발생할 가능성이 높음. (트레이드 오프 등장! 😇)

-> 디스크에 동기 처리를 한다면 데이터 정합성은 높아지지만 성능이 낮아짐.... 성능을 높이려면 데이터 정합성이 낮아짐. 뭘해도 어렵네 ^^

(데이터 정합성?! 데이터들의 값이 일치함을 의미⭐️)

5. 시스템 특성에 따른 트레이드오프
- 데이터 캐시에 비해 로그 버퍼의 초깃값이 굉장히 작은 것을 알 수 있슴! 왜? 데이터베이스가 기본적으로 검색을 메인으로 처리한다고 가정하기 때문에 ! (검색 SQL: 데이터 캐시 / 갱신 SQL: 로그 버퍼)

- 검색 처리를 할 때는 검색 대상 레코드가 수천만 건에 달할 정도로 많을 수 있음 but 갱신처리는 그에 비해 트랜잭션마다 한건에서 수만 건 정도밖에 안됨. 그러니까 갱신 처리에 값비싼 메모리를 많이 사용하는 것보다는 자주 검색하는 데이터를 캐시에 올려놓는 것이 좋다고 생각하는 것임 ! 🌱

* 검색과 갱신 중에서 중요한 것
그렇다면 검색과 갱신 중에서 뭐가 더 우선되어야할까??.?? 이건... 케바케!데이터베이스가 어떤 생각에 기반을 두고 리소스를 배분하고 있는지 이해하는 것이 굉장히 중요. 만약 로그 버퍼가 크게 잡혀있으면 갱신처리와 관련해서 부하를 예방하려고 설계한 것이겠고, 데이터 캐시가 크게 잡혀있다면 검색 처리와 관련된 처리가 중심이겠찌...^.^

6. 추가적인 메모리 영역 '워킹 메모리'
* 언제 사용? DBMS는 2개의 버퍼 이외에 일반적으로 메모리 영역 하나 더 가지고 있음: 워킹 메모리(working memory)
* 이 작업용 메모리 영역은 SQL에서 정렬 또는 해시가 필요할 때 사용되고, 종료되면 해제되는 임시영역임. 요 영역이 중요한 이유? 만약 이 영역이 다루려는 데이터양보다 작아 부족해지면 대부분의 DBMS가 저장소를 사용하기 때문! -> OS동작에서 말하는 스왑(swap)과 같은 것!

* 많은 DBMS는 워킹 메모리가 부족할 때 사용하는 임시적인 영역을 가지고 있음.
* 저장소가 부족하면 무슨 일이 일어날까? 저장소는 일반적으로 메모리에 비해 느림. 그래서 저장소에 접속하게 되면 당연히 전체적인 속도가 느려짐. 메모리에서 작동하고 있을 때는 빠르게 움직이다가, 메모리가 부족해지는 순간 갑자기 느려지는 순간적인 변화가 일어나는 것이 문제임.

* 이 영역은 여러 개의 SQL 구문들이 공유해서 사용하므로, 하나의 SQL 구문을 실행하고 있을 때는 메모리에 잘 들어가지만 여러 개의 SQL 구문을 동시에 실행하면 메모리가 넘치는 경우가 있음. 따라서 부하 검사를 계속 실시해 줌...! DBMS는 '메모리가 부족하더라도 무언가를 처리하려고 계속 노력하는 미들웨어'임!

#### 💛 3강 DBMS와 실행 계획
1. 권한 이양의 죄악
* RDB를 조작할 때는 SQL이라는 전용 언어를 사용함. 절차적, 비절차적 RDB 종류에 따라 권한을 이양하는 형태인데, 이렇게 권한을 이양하는 데는 '전체의 생산성을 향상하기 위한 목적'이 있음.

2. 데이터에 접근하는 방법은 어떻게 결정할까?
* ✍️ **RDB에서 데이터 접근 절차를 결정하는 모듈은 쿼리 평가 엔진**이라고 부름. 쿼리 평가 엔진은 사용자로부터 입력받은 SQL구문(쿼리)을 처음 읽어들이는 모듈이기도 함.
* 쿼리평가모듈: **파서, 옵티마이저 같은 여러개의 서브 모듈**로 구성.

![](https://images.velog.io/images/majaeh43/post/0fd628de-12de-4e19-8c1a-bee935df4b43/image.png)
1. 파서
* 📌1) 파서의 역할은 이름 그대로 파스(구문 분석)하는 것. 사용자로부터 입력받은 SQL 구문이 항상 구문적으로 올바르다는 보증이 없으므로 검사를 해주는 것. (서류 심사 같은 것: 쉼표 쓰는 것, from 구에 존재하지 않는 테이블 이름 쓰거나 했을 때 미리 떨어뜨리는 것)
* 파서는 SQL구문을 정형적인 형식으로 변환해줌. 그렇게해야 DBMS 내부에서 일어나는 후속 처리가 효율화되기 때문에! 

2. 옵티마이저
* 서류심사를 통과한 쿼리는 옵티마이저로 전송. 옵티마이저는 '최적화'. 이때 최적화의 대상은 데이터 접근법(실행 계획). 옵티마이저가 바로 DBMS의 핵심.
* 옵티마이저는 인덱스 유무, 데이터 분산 또는 편향 정도, DBMS 내부 매개변수 등의 조건을 고려해서 📌2) 선택 가능한 많은 실행 계획을 작성하고, 📌3) 이들의 비용을 연산하고, 가장 낮은 비용을 가진 실행 계획을 선택.

3. 카탈로그 매니저
* 옵티마이저가 실행계획을 세울 때 옵티마이저에 중요한 정보를 제공하는 것이 📌4) 카탈로그 매니저임. 카탈로그란 DBMS의 내부 정보를 모아놓은 테이블들로 테이블 또는 인덱스의 통계 정보가 저장되어 있음. 이러한 카탈로그 정보를 간단하게 '통계 정보'라고 부르기도 함.

4. 플랜평가
* 옵티마이저가 SQL 구문에서 여러 개의 실행 계획을 세운 뒤 그것을 받아 최적의 실행 결과를 선택하는 것이 📌5)플랜 평가임.

-> 이렇게 하나의 실행계획을 선택하면, 이후에 DBMS는 실행 계획을 절차적인 코드로 변환하고 데이터 접근을 수행함.

3. 옵티마이저와 통계 정보
* DBMS가 쿼리를 읽어들여 실제로 데이터 접근을 수행할 때까지의 흐름.
* 카탈로그 매니저가 관리하는 **통계 정보**에 대해서는 데이터베이스 엔지니어가 항상 신경써주어야 함.
* 옵티마이저가 플랜선택을 하는 경우 실패하는 경우가 종종있는데 통계정보가 부족한 경우임!
* 카탈로그에 포함되어 있는 통계 정보
-> 각 테이블의 레코드 수
-> 각 테이블의 필드 수와 필드의 크기
-> 필드의 카디널리티(값의 개수) 등등

* 이러한 정보를 활용해 옵티마이저는 실행 계획을 만듦! 문제가 생기는 경우는 이러한 카탈로그 정보가 테이블 or 인덱스의 실제와 일치하지 않을 때임! 테이블의 삽입/갱신/제거가 수행될 때, 카탈로그 정보가 갱신되지 않는다면 옵티마이저는 오래된 정보를 바탕으로 실행 계획을 세우게 됨. 옵티마이저는 과거 정보밖에 가지고 있지 않으니 어쩔 수 없이 잘못된 계획을 세울 수 밖에 없음...ㅠㅠ

4. 최적의 실행 계획이 작성되게 하려면?!
* 올바른 통계정보가 모이는 것은 SQL 성능에 있어서 굉장히 중요한 문제.
* 따라서 테이블의 데이터가 많이 바뀌면 카탈로그의 통계 정보도 함께 갱신해야 함.
* DBMS가 최적의 플랜을 선택하려면 필요한 조건이므로 갱신 시점을 확실하게 검토해야 함.
* 대표적인 DBMS의 통계 정보 갱신 명령어
```
💚 MySQL) analyze table [스키마이름].[테이블이름]; 💚
```
