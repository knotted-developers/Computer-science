
### 🤍 7장 복수의 테이블 다루기
#### 🤍 31강 집합 연산
* 내가 지금까지 배운 SQL명령은 대부분 '하나의 테이블'을 사용하는 것!
* 여기서부터는 '복수의 테이블'을 사용해 데이터를 검색하는 방법에 대해 알아볼 것!

1. SQL과 집합
* 벤다이어그램에서는 하나의 원이 곧 하나의 집합. 그 원 안에는 요소가 포함. 예를 들어 숫자 같은 것.
* 데이터베이스에서는 테이블의 행이 요소에 해당.
* select 명령을 실행하면 데이터베이스에 질의하며 그 결과 몇 개의 행이 반환됨. 이때 반환된 결과 전체를 하나의 집합이라고 생각하면 됨.

2. UNION으로 합집합 구하기
* 합집합: 집합을 서로 더한 것
* a = [1,2,3], b = [2,10,11], a와 b의 합집합 = [1,2,3,10,11]
* SQL에서는 select명령의 실행 결과를 하나의 집합으로 다룰 수 있음 -> UNION 키워드 사용
* 'A UNION B'라고 표현
```
🤍 select * from sample71_a
UNION
🤍 select * from sample71_b;
```
-> 두 개의 명령을 하나의 명령으로 합침!
-> 두 개의 select 명령을 하나의 명령으로 합치는 만큼 세미콜론(;)은 맨 나중에 붙임!

* 여러 개 합치는 것 가능. 단, select명령의 열의 내용(열 구성)은 서로 일치해야함.

* UNION을 사용할 때의 order by
UNION으로 select 명령을 결합해 합집합을 구하는 경우, 각 select 명령에 order by를 지정해 정렬할 수 없음. order by를 지정할 때는 마지막 select 명령에만 지정하도록 함.
![](https://images.velog.io/images/majaeh43/post/a86c324f-ea88-4123-97a6-1330aa76b8c6/image.png)
-> 에러 발생: order by를 지정할 수 있다해도 마지막 select 명령의 결과만 정렬하는 것이 아니고 합집합의 결과를 정렬하는 것이기 때문에! 두개의 select 명령에서 열 이름이 서로 일치한다는 보장이 없음!
-> 그럼 어떻게? 별명을 붙이기! C!
![](https://images.velog.io/images/majaeh43/post/856a6eae-a66b-4b39-9e66-240db4c35830/image.png)

* UNION ALL
-> UNION을 사용하면 중복값이 제거되어 처리됨. 근데 중복값 인정하고 그냥 합치고 있을 때도 있으니까...? 그런 경우에는 UNION ALL 사용!
-> 중복 제거 경우에는 distinct, 중복 제거하지 않고 모두 반환하는 경우: all
-> distinct가 기본값이고 all로 중복제거 여부를 지정할 수 있씀! 
![](https://images.velog.io/images/majaeh43/post/a8d4a5df-6569-4e25-b42b-c62e338d130c/image.png)
-> 사실 요 두 테이블에 중복값은 없지만 요렇게 명령어를 쳐주면 중복을 인정하는 값으로 데이터를 쭉 뽑을 수 있씀! 💘 근데 중복값이 없는 경우에도 UNION ALL을 사용하는게 좋은 성능을 보여준다고 함! *.*

3. 교집합과 차집합
* MySQL에서는 지원되지 않지만 SQL을 이용해 교집합, 차집합도 구할 수 있음!
* 교집합은 INTERSECT를, 차집합은 EXCEPT를 사용~!

#### 🤍 32강 테이블 결합
* **테이블 결합**은 RDBMS에서 쩰 중요 ⭐️⭐️⭐️⭐️⭐️ -> JOIN
* 지금까지는 세로(행) 방향으로 데이터가 늘거나 주는 걸 공부했따면! 이제부터는 가로(열) 방향으로 데이터가 늘어나는 계산~!
* 결합을 이해하는 동시에 기본이 되는 개념이 **'곱집합'**!

1. 곱집합과 교차결합
* 두 개의 집합을 곱하는 연산 방법.
* x = [A,B,C], y = [1,2,3] -> x와 y의 곱집합을 구하면?
-> A,1 / A,2 / A,3
-> B,1 / B,2 / B,3
-> C,1 / C,2 / C,3

* 교차결합: select 명령에서는 from 구에 하나의 테이블만 지정. 여기서 두개를 지정하면 곱집합으로 계산.

```
🤍 select * from 테이블명1, 테이블명2 🤍
```
![](https://images.velog.io/images/majaeh43/post/2e7b3902-9922-482e-a7d1-101318f8a0ef/image.png)
-> 요렇게 합쳤당!

* UNION 연결과 결합 연결의 차이
-> UNION으로 합집합을 구했을 경우에는 세로방향으로 더해짐 / from 구로 결합시 가로 방향으로 더해짐.

2. 내부결합
* 결합이 된다고는 하지만 테이블 수가 많아지면 조합 수가 엄청 느니까 집합이 거대해질거야.. 그래서 그걸 다 교차결합하는 경우는 드물당! 그래서 **교차결합 < 내부결합 더 자주 사용**!

* 데이터베이스에는 다양한 데이터가 저장. 이때 기본키는 하나의 데이터행을 대표할 수 있는 속성! 그래서 상품명보다는(중복가능성이 있으니깐!) 상품 코드를 '기본키'로 사용.

![](https://images.velog.io/images/majaeh43/post/9462a6dc-5149-4467-a532-eb1fbf3c90bc/image.png)
-> 요렇게 기본키는 상품코드로!
![](https://images.velog.io/images/majaeh43/post/7210892f-7db7-402e-9c84-3e8e74e4e20e/image.png)
* 재고테이블도 만들어볼까?
![](https://images.velog.io/images/majaeh43/post/40a56733-56cc-48be-a3e9-0f116dbb89a4/image.png)
![](https://images.velog.io/images/majaeh43/post/425f1d5e-d104-4d99-a8a0-076857726ef9/image.png)
-> 상품코드를 가진 재고수 테이블!
-> 재고수 테이블은 기본키인 상품코드를 통해 상품 테이블과 연결(참조)할 수 있다는 것을 기억해줭..! ⭐️

* 재고수 테이블에서 상품분류가 생활용품인 상품의 재고수를 표시하는 경우 -> 이 경우 상품코드보다 상품명으로 표시하면 알아보기 쉬울 것! 
-> 상품명 | 재고수
->  a   |   200
-> 이렇게 재고수 테이블과 상품 테이블을 결합해 가로로 나열하려면! from 구에서 테이블을 서로 결합함!
![](https://images.velog.io/images/majaeh43/post/1b6f53d6-9948-49b0-a75b-d7dbad221359/image.png)
-> 이렇게 from구에 테이블을 복수로 지정하면 곱집합으로 계산됨.
-> 이렇게 만들어진 집합에서 내가 원하는 데이터를 검색하려면? where 구로 조건을 지정. 단, '상품코드가 같다는 조건'이 필요!
```
🤍 select * from 상품, 재고수
    where 상품.상품코드 = 재고수.상품코드; 🤍
```
![](https://images.velog.io/images/majaeh43/post/8cf0c408-3324-4b8b-8732-91e243691eaf/image.png)
-> 이렇게 교차결합으로 계산된 곱집합에서 원하는 조합을 검색하는 것을 '내부결합'이라 부름!

* 이번에는 상품분류가 '생활용품'이라는 조건을 검색해보장!
```
🤍 select 상품.상품명, 재고수.재고수 from 상품, 재고수
    where 상품.상품코드 = 재고수.상품코드
    and 상품.상품분류 = '생활용품'; 🤍
```
![](https://images.velog.io/images/majaeh43/post/a2182f14-c889-48b4-97b7-8b29749d2052/image.png)
-> 따란~~~~🌈
-> where 구에 두개의 조건식이 지정되어있음! 1) 교차결합으로 계산된 곱집합에서 원하는 조합 검색 (=결합조건) 2) 결합조건이 아닌 검색조건

3. INNER JOIN으로 내부결합하기
* from 구에 테이블을 복수 지정해 가로 방향으로 테이블 결합가능
* 교차결합하면 곱집합으로 계산됨
* where 조건을 지정해 곱집합에서 필요한 조합만 검색할 수 있음!

* 위에꺼는 옛날 방법이라네..?^^ 이번에는 INNER JOIN 키워드를 사용한 결합방법을 사용해보장 !
```
🤍 select * from 테이블명1 inner join 테이블명2 on 결합조건 🤍
```
* INNER JOIN이라는 키워드를 사용해보는거양!

```
🤍 select 상품.상품명, 재고수.재고수
	from 상품 inner join 재고수
    	on 상품.상품코드 = 재고수.상품코드
    where 상품.상품분류 = '생활용품'; 🤍
```
![](https://images.velog.io/images/majaeh43/post/2e17768b-65b2-4e3f-9679-ab113093efbb/image.png)

* 내부결합 (INNER JOIN)
```
🤍 select * from 테이블명1 INNER JOIN 테이블명2 ON 결합조건 🤍
```
* 옛날 방법은 where 구에 결합조건을 지정하였지만 INNER JOIN에서는 **ON**을 사용하여 결합조건을 지정!

4. 내부결합을 활용한 데이터 관리
* 하나의 데이터는 한 군데에 저장한다- 는 룰에 따라 데이터 구조를 설계한다고 했을 때, 메이커코드와 메이커명을 가지는 '메이커 테이블'을 작성해 데이터를 관리해보겠음!

* 상품을 제조하는 메이커가 많이 있다고해도 상품수보다는 적음! 이때 코드와 이름을 가지는 테이블로 분할해 관리하면 저장공간 절약 가능! 메이커 테이블을 작성하는 명령과 저장할 데이터를 공부해보장...🌼

* 요렇게 먼저 메이커 table을 만들어주고~!
![](https://images.velog.io/images/majaeh43/post/8ebce4b2-0d15-45a1-958c-9c97a98e8c6b/image.png)
* desc 메이커 테이블 확인!
![](https://images.velog.io/images/majaeh43/post/5fd64560-113b-42be-8f2c-f7d4417d5ffb/image.png)
* 상품테이블과 메이커테이블을 내부결합해보장! 🌹
```
🤍 select 상품명, 메이커명 from 상품 INNER JOIN 메이커 ON 상품.메이커코드 = 메이커.메이커코드; 🤍
```
![](https://images.velog.io/images/majaeh43/post/e751d0e4-6cd5-4c07-9208-dc7753d13db9/image.png)

* 여기서 '메이커코드'는 너무 중요함.

* 외부키: 메이커 테이블의 메이커코드는 기본키. 그에 비해 상품 테이블의 메이커코드는 '외부키'. 다른 테이블의 기본키를 참조하는 열이 외부키가 됨!

* 자기결합(Self Join): 테이블에 별명을 붙일 수 있는 기능을 이용해 같은 테이블끼리 결합하는 것을 말함.

5. 외부결합
-> 결합방법: 내부결합, 외부결합
-> 외부결합: '어느 한 쪽에만 존재하는 데이터행을 어떻게 다룰지'를 변경할 수 있는 결합방법.

* 상품테이블에 상품코드가 4인 행을 새롭게 추가함.
![](https://images.velog.io/images/majaeh43/post/22e25510-556c-4df0-a244-3211bdca4f35/image.png)
-> 재고수 테이블에는 아직 이 상품에 대한 데이터가 없음. 이런 상태에서 곱집합을 구해도 내부결합 결과에서는 상품코드가 4인 상품이 제외됨. 🌼 **이런 경우 외부결합을 사용하면 됨!** 🌼
-> 외부결합든 결합하는 테이블 중 어느 쪽을 기준으로 할지 결정할 수 있음. **LEFT JOIN**을 사용해보장!
![](https://images.velog.io/images/majaeh43/post/d9e8b577-a7dc-440b-a220-fca205b47edf/image.png)
-> 재고수 테이블에는 상품코드=4 에 대한 데이터가 없으므로 값이 NULL로 표시됨! 기준이 되는 상품 테이블을 JOIN의 왼쪽에 기술했으므로 LEFT JOIN! 상품 테이블을 오른쪽에 지정하는 경우나 재고 테이블을 기준으로 삼고 싶은 경우에는 RIGHT JOIN을 사용해 외부결합을 시행함!
![](https://images.velog.io/images/majaeh43/post/d8d680a2-d11f-4e84-8cc4-5e05ce4325da/image.png)
-> 요건 right join을 사용한건데, right join 앞에 재고테이블의 재고수를 기준으로 삼았더니 같은 결괏값이 나옴! 기억해주기!

* MySQL은 외부결합 불가...^^ 최근에 나온 데이터베이스라서...^^

#### 🤍 33강 관계형 모델
* SQL은 관계형 모델에 의해 구축된 데이터베이스를 조작하는 체계적인 명령의 집합! 🐼
* 기본적인 요소 -> 릴레이션 (관계형 모델의 릴레이션은 SQL에서 말하는 **테이블**! 테이블끼리의 관계 NO!)

🐼 이제 insert into 랑 update 하는 것 등등 몇가지 명령어들은 손에 익기 시작했다. 더더더ㅓ더ㅓ더더덛ㄸ..... 더 손에 익히고 연습하고... 화이띵 ! 🐼
